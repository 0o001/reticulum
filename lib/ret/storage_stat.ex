defmodule Ret.StorageStat do
  @moduledoc """
  Defines table for StorageStat generated by Ret.StorageUsed on the interval
  Storage is captured only in TURKEY_MODE and saved in # units of 512 bytes that `du` uses by default
  """
  use Ecto.Schema
  import Ecto.Changeset
  import Ecto.Query
  alias Ret.{StorageStat, Repo}
  require NaiveDateTime
  require Logger

  schema "storage_stats" do
    field(:measured_at, :utc_datetime)
    field(:node_id, :binary)
    field(:present_storage_blocks, :integer)

    timestamps()
  end

  @doc false
  # TODO Could do an aggregate per day that each value factors into? Average might get tricky because you need the count of values you've put in
  def changeset(storage_stat, attrs) do
    storage_stat
    |> cast(attrs, [:node_id, :measured_at, :present_storage_blocks])
    |> validate_required([:node_id, :measured_at, :present_storage_blocks])
  end

  # Adds current storage_stat
  # storage_blocks is in # units of 512 bytes
  def save_storage_stat(storage_blocks) do
    Logger.warn("Saving storage: #{storage_blocks}")
    # if System.get_env("TURKEY_MODE") do
    with node_id <- Node.self() |> to_string,
         measured_at <- NaiveDateTime.utc_now() |> NaiveDateTime.truncate(:second),
         present_storage_blocks <- storage_blocks do
      %StorageStat{}
      |> changeset(%{
        node_id: node_id,
        measured_at: measured_at,
        present_storage_blocks: present_storage_blocks
      })
      |> Repo.insert()
    end

    # end
  end

  @seconds_in_a_day 24 * 60 * 60
  def get_list_of_today_values(utc_date) do
    {:ok, time} = Time.new(0, 0, 0, 0)

    {:ok, today_date} = \
      utc_date \
      |> NaiveDateTime.to_date() \
      |> NaiveDateTime.new(time)

    next_day_date = today_date |> NaiveDateTime.add(@seconds_in_a_day, :second)

    # TODO Will this have conflicts with different node_ids? or count twice if share same db?
    from(ss in StorageStat, where: ss.measured_at >= ^today_date and ss.measured_at < ^next_day_date)
    |> Repo.all()
  end

  # TODO better verification of list of %StorageStat
  def storage_stat_list_to_unit_list(list_storage_stats) do
    list_storage_stats
    |> Enum.map(fn ss -> ss.present_storage_blocks end)
  end

  def get_stats(unit_list) do
    avg = Enum.sum(unit_list) / Kernel.length(unit_list)
    max = Enum.max(unit_list)
    min = Enum.min(unit_list)
    %{avg: avg, max: max, min: min}
  end
end
